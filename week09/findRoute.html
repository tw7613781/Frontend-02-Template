<style>
  .cell {
    display: inline-block;
    line-height: 7px;
    width: 6px;
    height: 6px;
    background-color: grey;
    border-bottom: solid 1px white;
    border-right: solid 1px white;
    vertical-align: top;
  }
  #container{
    width: 701px;
  }
</style>
<div id="container"></div>

<button onclick="localStorage['map'] = JSON.stringify(map)">save</button>

<script>
  class Sorted {
    // 这个compare能提供一个定制比较的能力
    constructor(data, compare){
      this.data = data.slice()
      this.compare = compare || ((a, b) => a - b)
    }
    take() {
      if(!this.data.length) return
      let min = this.data[0]
      let minIndex = 0

      for(let i=1;i<this.data.length;i++){
        if(this.compare(this.data[i], min)<0) {
          min = this.data[i]
          minIndex = i
        }
      }
      // splice是个O(n)的操作，下面这个方式是O(1)的操作
      this.data[minIndex] = this.data[this.data.length-1]
      this.data.pop()
      return min
    }
    give(v) {
      this.data.push(v)
    }
  }
  let map = localStorage['map']?JSON.parse(localStorage['map']):Array(10000).fill(0)
  let container = document.getElementById('container')
  for(let y = 0; y < 100; y++){
    for(let x = 0; x < 100; x++) {
      let cell = document.createElement('div')
      cell.classList.add('cell')
      if(map[100*y + x] === 1) {
        cell.style.backgroundColor = 'black'
      }
      cell.addEventListener('mousemove', ()=> {
        if(mousedown) {
          if(clear) {
            cell.style.backgroundColor = ''
            map[100*y+x] = 0
          } else {
            cell.style.backgroundColor='black'
            map[100*y+x] = 1
          }
        }
      })
      container.appendChild(cell)
    }
  }

  let mousedown = false
  let clear = false
  document.addEventListener('mousedown', e => {
    mousedown = true
    clear = (e.which === 3)
  })
  document.addEventListener('mouseup', ()=>mousedown=false )
  // 阻止右键的弹出菜单
  document.addEventListener('contextmenu', e=>e.preventDefault())

  function sleep(t) {
    return new Promise((resolve, reject)=>{
      setTimeout(resolve, t);
    })
  }
  
  async function path(map, start, end) {
    let table = Object.create(map)
    var queue = new Sorted([start], (a,b)=>distance(a)-distance(b))

    async function insert(x,y, pre){
      if(x<0 || x>=100 || y<0 || y>=100) return
      // 无论是1（有障碍），还是2（走过）都不入队列了
      if(table[x*100+y]) return
      await sleep(30)
      // 不睡一下的话，ui更新可能跟不上
      container.children[x*100 + y].style.backgroundColor = 'lightgreen'
      // 把之前的点加进去，方面找到终点的时候回溯路径
      table[x*100 + y] = pre
      queue.give([x,y])
    }
    function distance(point) {
      return (point[0] - end[0])**2 + (point[1]-end[1])**2
    }

    while(queue.data.length) {
      let [x,y] = queue.take()
      let tempx
      let tempy
      // console.log(x,y)
      if(x === end[0] && y === end[1]) {
        let path = []
        while(x!=start[0] || y!=start[1]) {
          path.push([x,y])
          container.children[x*100+y].style.backgroundColor = 'purple'
          tempx=table[x*100+y][0]
          tempy=table[x*100+y][1]
          x=tempx
          y=tempy
        }
        return path
      }
      await insert(x-1, y, [x,y])
      await insert(x, y-1, [x,y])
      await insert(x+1, y, [x,y])
      await insert(x, y+1, [x,y])

      await insert(x-1, y-1, [x,y])
      await insert(x+1, y-1, [x,y])
      await insert(x-1, y+1, [x,y])
      await insert(x+1, y+1, [x,y])
    }
    return false
  }
</script>