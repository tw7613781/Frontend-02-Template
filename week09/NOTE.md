学习笔记

# 编程与算法训练

编程训练包括

- 算法，数据结构：如何去做

- 语言本身：如何用语言更好的表达

## 1. TicTacToe，三子棋，一条龙

- 用二维数组表示棋盘，二维数组在使用的时候，第一个index表示的是外层array，即横，第二个index表示的里层的array，即竖

- 优化的时候使用了一维数组来实现棋盘，主要使用了x*3+y的关系。好处是节省了内存。并且在clone数组的时候可以不使用JSON库了，直接使用`Obeject.create()`

- 花括号能形成一个局部作用域，可以在里面对变量进行反复赋值使用。

- 使用标记来实现break跳出多层循环

- AI方面使用了递归暴力遍历了所有的结果，找出了最优点。因为棋盘够小，所以性能不是问题了。不然的话，稍微大一点的五子棋就不能暴力搜了，得加搜索深度了。

## 2. 异步编程

- Promise的一些方法来完成一些逻辑

  - all()：必须所有的promise都fulfill掉

  - race()：其中一个promise它fulfill了就行

- 在没有async/await的年代，使用generator去模拟它们的功能

## 3. 广搜

## 3.1 广搜的基本算法思想

基本思想是维持一个数组，里面是待处理的点。

不断从这个数组拿出点，看它能走到的点，然后把这些点再加到上面的数组中去。

可以再维护一个走过的点的数组或者标注一个特殊的状态，这样在第二步判断是否能走到的点的时候，就两个条件了，一个是不走走过的点，一个是不走有障碍物的点。

直到第一步的数组里面为空或者找到终点了。

第一步的数组的初始值为起点。

## 3.2 广搜的实现和应用

广搜不适合使用递归，递归比较适合于深搜。然后在寻路算法中，广搜是比较合适的。

## 3.3 JavaScript 语法点

- js的array是天然的queue（先进先出），有两组函数push, shift

- js的array也是天然的stack（后进先出），有两组函数push, pop

## 3.4 深搜的实现

把push和shift变为push和pop就行了，把queue变为stack。所有的搜索的算法的精髓都这个待处理的点的集合的表示方法，可以是queue，可以是stack，也可以是排序的接口，就变为A*搜索了。

## 3.5 性能

广搜明显是去穷举加一点点剪枝（重复的和有障碍的），性能是比较差的。

可以使用启发式算法，就是用一个函数去判断找路的优先级。本质上也是穷举，但是加点更高级的剪枝。能找到最佳路径的启发式寻路叫做a*，不能找到最佳路径的启发式寻路叫做a。

启发式算法的实现：函数的主体结构不用改变，只需要把queue改为一个能提供优先级的一种数据结构。

sorted数据结构，take的时候拿出一个最小的，give的时候无所谓。这种数据结构有很多，著名的有heap（堆），winner tree，排序二叉树